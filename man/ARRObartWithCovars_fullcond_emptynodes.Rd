% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BARModel.R
\name{ARRObartWithCovars_fullcond_emptynodes}
\alias{ARRObartWithCovars_fullcond_emptynodes}
\title{Auto-regressive BART model for Bayesian Analysis of Rank-Order data with Covariates}
\usage{
ARRObartWithCovars_fullcond_emptynodes(
  pair.comp.ten,
  X.train = matrix(NA, nrow = dim(pair.comp.ten)[1], ncol = 0),
  X.test = matrix(NA, nrow = 0, ncol = 0),
  n.item = dim(pair.comp.ten)[1],
  n.rankerbytime = dim(pair.comp.ten)[3],
  n.ranker,
  n.time,
  p.cov = ncol(X.train),
  iter.max = 5000,
  para.expan = TRUE,
  print.opt = 100,
  initial.list = NULL,
  n.trees = 50L,
  n.burn = 0L,
  n.samples = 1L,
  n.thin = 1L,
  trans_prob = c(2.5, 2.5, 4)/9,
  n.chains = 1,
  n.threads = 1L,
  printEvery = 100L,
  printCutoffs = 0L,
  rngKind = "default",
  rngNormalKind = "default",
  rngSeed = NA_integer_,
  updateState = FALSE,
  num_lags = 1,
  diff_num_test_rankers = 0,
  keep_zmat = FALSE,
  noise_in_pred = 0,
  seq_z_draws = 1,
  N_hdr = 100,
  rho_hdr = 0.5,
  smoothing_method = "AR",
  num_horizon = 1,
  num_z_iters = 10,
  itemcovars = FALSE,
  node_min_size = 5,
  k = 2,
  sigquant = 0.9,
  alpha = 0.95,
  beta = 2,
  nu = 3,
  lambda = 0.1,
  sparse = TRUE,
  no_empty_proposals = FALSE,
  alpha_prior = FALSE,
  sigma_mu_prior = FALSE,
  splitting_rules = "discrete",
  max_bad_trees = 10
)
}
\arguments{
\item{pair.comp.ten}{An \eqn{N} by \eqn{N} by \eqn{MT} pairwise comparison tensor for all \eqn{N} entities and \eqn{M} rankers and \eqn{T} time periods, where the (\eqn{i},\eqn{j},\eqn{m}) element equals 1 if \eqn{i} is ranked higher than \eqn{j} by ranker \eqn{m}, 0 if \eqn{i} is ranker lower than \eqn{j}, and NA if the relation between \eqn{i} and \eqn{j} is missing. Note that the diagonal elements (\eqn{i},\eqn{i},\eqn{m})'s for all rankers should be set to NA as well.}

\item{X.train}{An \eqn{N} by \eqn{L} training covariate matrix for the \eqn{N} entities with \eqn{L} covariates. If there are ranker-specific or time-specific covariate values, then the matrix should have N*MT rows where MT is the number of rankers multiplied by the number of time periods. The first N rows correspond to ranker 1, the next N rows correspond to ranker 2, and so on.}

\item{X.test}{An \eqn{N} by \eqn{L} test covariate matrix for the \eqn{N} entities with \eqn{L} covariates. If there are ranker-specific or time-specific covariate values, then the matrix should have N*MT rows where MT is the number of rankers multiplied by the number of time periods. The first N rows correspond to ranker 1, the next N rows correspond to ranker 2, and so on.}

\item{n.item}{Number of entities/items being ranked.}

\item{n.rankerbytime}{Number of rankers multiplied by number of time periods}

\item{n.ranker}{Number of rankers}

\item{n.time}{Number of time periods}

\item{p.cov}{Number of covariates.}

\item{iter.max}{Number of iterations for Gibbs sampler.}

\item{para.expan}{?unused? Logical variable for whether using parameter expansion in the Gibbs sampler.}

\item{print.opt}{Print every print.optnumber of Gibbsa samples.}

\item{initial.list}{List of initial values for the Gibbs sample. If not null, must contain elements named Z.mat and mu.}

\item{n.trees}{(dbarts option) A positive integer giving the number of trees used in the sum-of-trees formulation.}

\item{n.chains}{(dbarts option) A positive integer detailing the number of independent chains for the dbarts sampler to use (more than one chain is unlikely to improve speed because only one sample for each call to dbarts).}

\item{n.threads}{(dbarts option) A positive integer controlling how many threads will be used for various internal calculations, as well as the number of chains. Internal calculations are highly optimized so that single-threaded performance tends to be superior unless the number of observations is very large (>10k), so that it is often not necessary to have the number of threads exceed the number of chains.}

\item{printEvery}{(dbarts option)If verbose is TRUE, every printEvery potential samples (after thinning) will issue a verbal statement. Must be a positive integer.}

\item{printCutoffs}{(dbarts option) A non-negative integer specifying how many of the decision rules for a variable are printed in verbose mode}

\item{rngKind}{(dbarts option) Random number generator kind, as used in set.seed. For type "default", the built-in generator will be used if possible. Otherwise, will attempt to match the built-in generator’s type. Success depends on the number of threads.}

\item{rngNormalKind}{(dbarts option) Random number generator normal kind, as used in set.seed. For type "default", the built-in generator will be used if possible. Otherwise, will attempt to match the built-in generator’s type. Success depends on the number of threads and the rngKind}

\item{rngSeed}{(dbarts option) Random number generator seed, as used in set.seed. If the sampler is running single-threaded or has one chain, the behavior will be as any other sequential algorithm. If the sampler is multithreaded, the seed will be used to create an additional pRNG object, which in turn will be used sequentially seed the threadspecific pRNGs. If equal to NA, the clock will be used to seed pRNGs when applicable.}

\item{updateState}{(dbarts option) Logical setting the default behavior for many sampler methods with regards to the immediate updating of the cached state of the object. A current, cached state is only useful when saving/loading the sampler.}

\item{num_lags}{Number of lags of the latent vairable to use as splitting variables.}

\item{diff_num_test_rankers}{Equal to 1 if there is a different number of rankers in the test data than in the training data.}

\item{keep_zmat}{Boolean. If equal to TRUE output the draws of Zmat for training data and test data}

\item{noise_in_pred}{If equal to 1, keep noise in test prediction calculations}

\item{seq_z_draws}{deprecated option for drawing latent variable values within MCMC}

\item{N_hdr}{number of draws for Holmes-Diaconis-Ross algorithm applied to linearly constrained Gaussians (Algorithm 1 of Gessner et al.). Used for calculation of integrals within sampling of latent variables in MCMC.}

\item{rho_hdr}{Rho parameter for Holmes-Diaconis-Ross algorithm applied to linearly constrained Gaussians (Algorithm 1 of Gessner et al.). Used for calculation of integrals within sampling of latent variables in MCMC.}

\item{smoothing_method}{Method for sampling the latent variable from the smoothing distribution within MCMC. If "AR", then Accept-Reject sampling. If "MH", then Metropolis-Hastings sampling.}

\item{num_horizon}{Number of time periods into the furture to predict ranks.}

\item{num_z_iters}{Number of Gibbs iterations for latent outcome z samples per overall MCMC iteration.}

\item{itemcovars}{Set equal to TRUE if covariates vary across items, and FALSE otherwise.}

\item{tau2.alpha}{The scale parameter for the scaled inverse chi-squared prior on \eqn{\sigma^2_alpha}.}

\item{nu.alpha}{The d.f. for the scaled inverse chi-squared prior on \eqn{\sigma^2_alpha}.}

\item{tau2.beta}{The scale parameter for the scaled inverse chi-squared prior on \eqn{\sigma^2_beta}.}

\item{nu.beta}{The d.f. for the scaled inverse chi-squared prior on \eqn{\sigma^2_beta}.}
}
\value{
A list is returned containing the following elements:
\item{mu}{A matrix of dimension n.item.n.ranker.n.time by iter.max. Columns correspond to MCMC iterations. Each column gives direct predictions given the previous lagged draws of Z (no filtering or smoothing, not in agreement with observed ranks). The rows are ordered with all items for ranker 1 in time period 1, then all items for ranker 2 in time period 1, and so on. }
\item{mu_test}{A matrix of dimension n.item.n.ranker.num_horizon by iter.max. Columns correspond to MCMC iterations. Each column gives direct predictions given the previous lagged draws of Z (no filtering or smoothing, not in agreement with observed ranks). The rows are ordered with all items for ranker 1 in the first horizon, then all items for ranker 2 in the first horizon, and so on. }
\item{Z.mat}{A 3d array of dimenions c(n.item, n.ranker*n.time, iter.max). Each slice corresponds to an MCMC iteration. The first n.ranker columns are for all rankers in the first time period. The second n.ranker columns are for the second time period, and so on.}
\item{Z.mat.test}{A 3d array of dimenions c(n.item, n.ranker*num_horizon, iter.max). Each slice corresponds to an MCMC iteration. The first n.ranker columns are for all rankers in the first time horizon. The second n.ranker columns are for the second time horizon, and so on.}
}
\description{
Implement the Bayesian model for rank-order data with at most 1 lag of the latent variable (and filtering and smoothing) and with covariate information.
}
